Pseduocode Code 

Procedure greedy_cost(move_dict, n, greedy_dict)
Input: 
	move_dict: a dictionary consisting of all the moves for this instance
	n: the size of number to start with
	greedy_dict: a dictionary consisting of all the greedy costs that we calculated so far (the first n-1 items)
Output: 
	The total cost of making the moves generated by the greedy algorithm 

	legal_move = moves such that n % move == 0
	ratios = an array of move/cost ratios for all legal moves 
	move_index = 0 # index of a previous move we want to build on 

	for i in [0, len(legal_move)):
		if  ratios[i] > ratios[move_index]: 
			move_index = i
		if ratios[i] == ratios[move_index] and legal_move[i] > legal_move[move_index]:
				move_index = i 
	move = legal_move[move_index]

	if move == 1:
		dest = n - 1 
	else: 
		dest = n/move
	cost = move_dict[move] + greedy_dict[dest]
	return cost 

	Procedure optimal_cost(move_dict, n, optimal_dict)
	Input: 
		move_dict: a dictionary consisting of all the moves for this instance
		n: the size of number to start with
		greedy_dict: a dictionary consisting of all the greedy costs that we calculated so far (the first n-1 items)
	Output: 
		The total cost of making the moves generated by the optimal solution 

	legal_move = moves such that n % move == 0
	legal_dest = [index to start with correponding to each move]
	cost_arr = []
	for i in range(0, len(legal_move)):
		cost_arr.append(move_dict[legal_move[i]] + optimal_dict[legal_dest[i]])
		move_index = cost_arr.index(min(cost_arr))
	return cost_arr[move_index]

def min_greedy_failure(instance):
	n = 0
	greedy_dict = {0:0}
	optimal_dict = {0:0}
	g_cost = 0
	o_cost = 0
	while g_cost == o_cost: 
		n += 1
		g_cost = greedy_cost(instance, n, greedy_dict)
		o_cost = optimal_cost(instance, n, optimal_dict)	
		greedy_dict[n] = g_cost
		optimal_dict[n] = o_cost
	return n 






